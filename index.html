<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>MTMCSim: Multithreaded Monte Carlo Simulation platform. (MTMCSim)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MTMCSim
   &#160;<span id="projectnumber">0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Multithreaded Monte Carlo Simulation platform. (<a class="el" href="namespace_m_t_m_c_sim.html">MTMCSim</a>) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="author"></a>
Author and contact information</h1>
<p>Author: Shizheng Li</p>
<p>Contact: szli.code AT gmail</p>
<p>This project was mostly done when he was a PhD student at Dept. of Electrical and Computer Engineering, Iowa State University.</p>
<p>Most development was done between 2009 and 2010. Revisited in 2013 for a build system rework and making it open source.</p>
<p>Source codes are avaliable at <a href="https://github.com/szli/MTMCSim">https://github.com/szli/MTMCSim</a></p>
<h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>This project indends to have a generic platform for mulththreaded Monte Carlo simulations. As long as the simulation is written according to the interface (abstract class <a class="el" href="class_m_t_m_c_sim_1_1_m_t_m_c_sim_base.html" title="The (abstract) base class for a multithread supported simulator. ">MTMCSim::MTMCSimBase</a>), the multithreading will be handled behind the scene. The multithreading scheduler runs under boss-worker mode. The boss thread generates random number sequences and the worker threads performs specified simulations. In current version, there is only one random number generator (RNG), thus one boss thread. We may have parallel RNG in the future. Therefore, it is best suited for simulations where the RN generation is simple compared to the algorithm run at each instance of the simulation. The project is designed in a purely object oriented manner in C++. This makes the project easy to maintain and extend. Almost all pointers in this project are boost::shared_ptr. All containers are from C++ STL. In this project, we call the data that gives one sample output to be a frame. For example, in communications theory, a frame is a data frame to be transmitted and received. In Monte Carlo simulation, we simulation many frames to get many samples and average over them. This terminalogy is used in communication and coding theory. In other fields, the terminalogy could be different.</p>
<p>This project also provides a friendly user interface. All the inputs are handled through text files and the user can change the display and save format easily. It is not hard to provide a Python interface given the current design.</p>
<p>Why not use MPI? The reason was simple. We did not have a super computer to run simulations. Our available hardware was several Linux servers with 4,8, or 16 cores. In such a case, threading is a not bad choice (of course MPI also works)</p>
<p>This documentation is brief. Only displays public members of each classes and documentations for some of the members.</p>
<h1><a class="anchor" id="sys"></a>
Build and Environment</h1>
<p>The project is portable between Windows and Linux. Tested under Windows 7 32-bit and 64-bit, Visual Studio 2010 and Fedora 13 and Centos 6.3 with Gcc 4.4.</p>
<p>The project requires Boost library. No strict requirement on versions. Tested under 1.43/1.44/1.47 version. Boost::thread must be built on the system. Boost shared_ptr is heavily used.</p>
<p>We use CMake as the build tool. This allow cross-platform builds. You can generate Visual Studio solution/project files, or make files, or nmake files, etc.</p>
<p>To obtain high performance, the hardware should offer good parallel compute capability. Typically the number of working threads equals to the number of CPU cores.</p>
<h1><a class="anchor" id="structure"></a>
Main Structure</h1>
<h2><a class="anchor" id="core"></a>
Core Infrastructure Classes</h2>
<p><a class="el" href="class_m_t_m_c_sim_1_1_m_t_m_c_scheduler.html" title="Multithread Monte Carlo Simulator Boss-Worker model scheduler. ">MTMCSim::MTMCScheduler</a>: Multithreading scheduler class. Handles thread creation, synchronization, buffering, etc.</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1_m_t_m_c_sim_base.html" title="The (abstract) base class for a multithread supported simulator. ">MTMCSim::MTMCSimBase</a>: Base class of simulators. All simulator should be derived from this class.</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1_simu_para.html" title="Base class for simulation paramaters. ">MTMCSim::SimuPara</a>: Base class of simulation parameters. All simulaton parameters should be derived from this class. See details in the <a class="el" href="index.html#ui">User Interface</a> section.</p>
<p>Factory pattern (<a class="el" href="class_m_t_m_c_sim_1_1_simu_factory.html" title="Factory class for classes derived from MTMCSimBase, the simulators. ">MTMCSim::SimuFactory</a>, <a class="el" href="class_m_t_m_c_sim_1_1_simu_para_factory.html" title="Factory class for classes derived from SimuPara, the simulation parameter objects. ">MTMCSim::SimuParaFactory</a>) is used to produce simulator objects and simulation parameter objects.</p>
<p>The <a class="el" href="_c_make_files_22_88_811_82_2_compiler_id_c_2_c_make_c_compiler_id_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a> function is in RumSimu.cpp.</p>
<h2><a class="anchor" id="simulators"></a>
Current Implemented Simulators (Mainly for coding theory)</h2>
<p><a class="el" href="class_m_t_m_c_sim_1_1_d_s_c_k_v_sim.html">MTMCSim::DSCKVSim</a>: Koetter-Vardy algorithm for distributed source coding.</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1_k_v_chan_sim.html" title="Koetter-Vardy decoding simulation for channel coding. ">MTMCSim::KVChanSim</a>: Koetter-Vardy algorithm for channel coding. This is the simplest use of this simulation program.</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1_mul_stage_sim.html" title="Simulator for multistage LDPC for two source distributed source coding. ">MTMCSim::MulStageSim</a>: Multistage LDPC codes for distributed source coding. Use rate adaptive LDPC codes, designed by David Varodayan et.al. (<a href="http://ivms.stanford.edu/~varodayan/ldpca.html">http://ivms.stanford.edu/~varodayan/ldpca.html</a>)</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1_m_s_a_l_sim.html" title="Simulator for multistage LDPC for two source distributed source coding. ">MTMCSim::MSALSim</a>: Multistage LDPC codes for distributed source coding. Use optimized codes for AWGN channels, designed using PEG algorithm. Not rate adaptive code, but better performance</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1_mul_sour_sim.html" title="Multiple source linear correlation model simulation. ">MTMCSim::MulSourSim</a>: Multisource distributed source coding based LDPC codes for linear equation correlation.</p>
<p>The above simulations work in a "FER" mode. We keep simulating frames until we see 100 error frames (configurable), and compute FER. If multi run mode is implemented, we change the code rate and <b>run new simulations</b> in order to get close to a code rate that gives FER &lt; 10^-3. The code rate is the "error free" code rate.</p>
<p>For rate adaptive codes, we can also run simulation in a "Rate" mode. In one instance of Monte Carlo simulation, we change the code rate until the decoding is successful. This can be done in practice since the codes are rate-adaptive, just transmit more parity bits. We simulate 100 (configurable) frames and average the code rate, this is the average required code rate to achieve "error free" transmission.</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1_mul_stage_sim_rate.html" title="Simulator for multistage LDPC for two source distributed source coding. ">MTMCSim::MulStageSimRate</a> and <a class="el" href="class_m_t_m_c_sim_1_1_mul_sour_sim_rate.html" title="Multiple source linear correlation model simulation. ">MTMCSim::MulSourSimRate</a> implements the "Rate" mode.</p>
<p>A simulation that implements <a class="el" href="class_m_t_m_c_sim_1_1_multi_run_simu_base.html" title="The base class for the simulators that are multi-runnable and support our multithread interface...">MTMCSim::MultiRunSimuBase</a> can run in "multi run" mode. It allows you to change your parameter and run the simulation again, until you set a quit flag to be true. Currently it is used to change the code rate heuristically to find rate that gives FER&lt;10^-3.</p>
<p>For a complete list of class hierarchy, please see <a href="hierarchy.html">Class Hierarchy</a> .</p>
<h2><a class="anchor" id="utils"></a>
Utilility classes</h2>
<p>Here are some classes and functionarities that may be reused by other research projects.</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1pdf_x_y.html" title="Handles joint pmf for two sources. ">MTMCSim::pdfXY</a> Joint probablity densigy (mass) function for two non-binary sources. It can be qary symmetric sources, or pdf (pmf more procisely) given by a file. It computes entropy, conditional entropy, mutual information, marginal pdf, etc.</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1discrete__distribution.html" title="Discrete Distribution, generates random number according to given pmf from uniform RVs...">MTMCSim::discrete_distribution</a> Random number generator for 1D general discrete probability distributions. It follows boost::random interface convention. It takes in a vector of double that gives the pmf. The algorithm is "slow start and fast generate". At startup time, it creates two tables for generating RNs, it is a bit slow, but when actual generating discrete random RVs, it is very fast. (So it is different from the "interval look up"). The table can be cached and reused, further reduces the start up time after one distribution is used once.</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1nb_to_bin_p_d_f_conv.html" title="Converts a pmf on alphabet with size nbSize to log_2(nbSize) binary sources with a joint pdf...">MTMCSim::nbToBinPDFConv</a> Converts a pmf on alphabet with size nbSize to log_2(nbSize) binary sources with a joint pdf. Also computes conditional entropies and conditional probabilities condition on K number of bits where K between 0 to log_2(nbSize).</p>
<p><a class="el" href="class_m_t_m_c_sim_1_1_l_d_p_c_dec.html">MTMCSim::LDPCDec</a> General LDPC decoder using belief-propgation algorithm written by my advisor Aditya Ramamoorthy. It supports ordinary LDPC decoding (find a code word) or decode to syndrome (finding a vector in a coset corresponding to the syndrome), which is useful for distributed source coding.</p>
<h1><a class="anchor" id="ui"></a>
User Interface</h1>
<p>The user interface is written in a pure OO manner and intended to potentially support GUI or Python in the future. </p>
<h2><a class="anchor" id="input"></a>
Input files</h2>
<p>The input parameters are given in text files. Typically, there are two input files. One is the top level configuration file, the file name is MTMCSimconf.txt by default, or is the input paramater of the exetuable file. A typical top configuration file looks like as follows.</p>
<p><em> simulation name = MulStageSim % Simulation name tells which simulator to load <br/>
 workingDir=./ <br/>
 profile file name=MuStSimuNew/QARY256_1.txt % The file name of the simulation configuration..Relative path from working Dir. <br/>
 temp file name=MuStSimuNew/MulStagetempFile.txt % Temporary resultion file name. Relative path from working Dir .<br/>
 format file name=MuStSimuNew/MuStFormat.txt Output format file name.Relative path from working Dir. <br/>
 queueSize=8 % The size of the buffer queue between boss thread and working thread. <br/>
 nThreads=4 The number of working threads.<br/>
 multiple run mode = 0 % 1 if automatically run simulatin using different parameters, the simulation should be <a class="el" href="class_m_t_m_c_sim_1_1_multi_runnable.html" title="The interface (abstract base class) for multi-runnable simulators. ">MTMCSim::MultiRunnable</a>.<br/>
 no simulation = 0 % If this is 1, we do not run the simulation. Only displays the parameters and computed results. <br/>
 </em> In general, the input files in this project have the form like above. Each effecive line has the format Parameter name = Parameter value, and the space or tab before and after the "=" will be ignored. Any line without "=" will be comment line. In an effective line, any string after % will be comments.</p>
<p>Another input file gives detailed configuration of a specific simulation. Its file name is specified by "profile file name". Here is an example. <em> QARY symmetric correlation. KV for Distributed source coding.</em></p>
<p><em>alphabet size = 256 <br/>
 code length = 255<br/>
 info length = 65<br/>
 pdf para = #QARY 0.4<br/>
 seed = 50<br/>
 lambda = 100.99<br/>
</em></p>
<p><em>max error frame = 100 % Max # of error frame to be simulated, termination condition. <br/>
 display freq = 10 % Display temporary results every "display freq" frames. <br/>
 save freq = 500 % Save temporary results every "save freq" frames.<br/>
 save file = DSCKVSim/QARY256Res_Debug. % Result file name. txt<br/>
 multiple run mode = 1<br/>
</em></p>
<p><em></em></p>
<p>The names of the parameters and meanings of the parameters are determined by specific simulator class.</p>
<h2><a class="anchor" id="out"></a>
Output files</h2>
<p>The output file format is given by a format file. The results are categorized into Simulation Results and Computed Results. Computed Results are computed from the parameters, e.g., the source entropy, the channel capacity, etc. The format file specifies the format to display input parameters and the computed results. Here is one line of the format file.</p>
<p>Alphabet Size $alphabet size$, PDF Type $pdf para$. HX = @ HX @, HY = @ HY @, H(Y|X) = @ HYX </p>
<p>The parameter names are in between the $ symbol and the computed result names are in between the @ symbol. In the result file, the strings containing $ and @ will be replaced by the actual parameters or computed results. The user can change the display format and result file format easily. In the current version, the display and result file formats are the same. But it is easy to modified the code so that they are different.</p>
<h2><a class="anchor" id="under_the_hood"></a>
Parameter handling under the hood</h2>
<p>This part gives some implementation details about the user interface. This is useful for people who want to write the simulator by themselves.</p>
<p>The parameters for a specific simulator are saved in a nested class of the simulator, which is derived from <a class="el" href="class_m_t_m_c_sim_1_1_simu_para.html" title="Base class for simulation paramaters. ">MTMCSim::SimuPara</a>. The parameters are stored in public data members of the specific parameter class. The input text file is read by <a class="el" href="class_m_t_m_c_sim_1_1_text_file_input.html" title="Process input from a text file and convert to a parameter map (map&lt;string, string&gt;). ">MTMCSim::TextFileInput</a> class and converted the an intermediate map (std::map&lt;string,string&gt;) that maps the parameter name to the parameter value. Then, a specifed version of virtual function <a class="el" href="class_m_t_m_c_sim_1_1_simu_para.html#abb799f3a2f8bd2fd3a31ca2ad618172f" title="Load the parameters from a mapping, which is obtained from some form of user interface. ">MTMCSim::SimuPara::loadPara()</a> should be called (usually called in a polymorphism manner) and the parameters will be converted to values according to their types and save to the data members of a specified parameter class. Each specified parameter class should define its own <a class="el" href="class_m_t_m_c_sim_1_1_simu_para.html#abb799f3a2f8bd2fd3a31ca2ad618172f" title="Load the parameters from a mapping, which is obtained from some form of user interface. ">MTMCSim::SimuPara::loadPara()</a> realization.</p>
<p>The computed results for a specific simulator are saved in a nested class of the simulator, which is derived from <a class="el" href="class_m_t_m_c_sim_1_1_comp_res.html" title="Base class for computed results. ">MTMCSim::CompRes</a>. The <a class="el" href="class_m_t_m_c_sim_1_1_comp_res.html" title="Base class for computed results. ">MTMCSim::CompRes</a> class defines a virtual function MTMCSim::CompRes::setMapping() to convert the results in data members to std::map&lt;string,string&gt;. <a class="el" href="namespace_m_t_m_c_sim_1_1_util.html#a1a9058d0d0ea563200d33536dcc2f7e9" title="Put the parameters and computed results into a formatted string whose format is given by a text file...">MTMCSim::Util::getFormattedStr()</a> will convert the parameters and computed results into string using given format.</p>
<h1><a class="anchor" id="howto"></a>
How to write a simulation</h1>
<p>To write a specified simulation, a simulator class should be derived from <a class="el" href="class_m_t_m_c_sim_1_1_m_t_m_c_sim_base.html" title="The (abstract) base class for a multithread supported simulator. ">MTMCSim::MTMCSimBase</a> class. See the doc of <a class="el" href="class_m_t_m_c_sim_1_1_m_t_m_c_sim_base.html" title="The (abstract) base class for a multithread supported simulator. ">MTMCSim::MTMCSimBase</a> for more information.</p>
<p>A good example of such a simulator with detailed comments is <a class="el" href="class_m_t_m_c_sim_1_1_k_v_chan_sim.html" title="Koetter-Vardy decoding simulation for channel coding. ">MTMCSim::KVChanSim</a> and <a class="el" href="class_m_t_m_c_sim_1_1_mul_stage_sim.html" title="Simulator for multistage LDPC for two source distributed source coding. ">MTMCSim::MulStageSim</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jul 21 2013 01:02:14 for MTMCSim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
